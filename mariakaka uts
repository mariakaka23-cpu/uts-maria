Soal 1 — Keterkaitan SaaS, PaaS, dan IaaS

IaaS (Infrastructure as a Service)** menyediakan infrastruktur dasar: server virtual (VM), storage, jaringan — pengguna mengelola OS, middleware, runtime, aplikasi. Contoh: AWS EC2, Google Compute Engine.

PaaS (Platform as a Service)** berada di atas IaaS; menyediakan platform runtime yang sudah dikelola (container platform, buildpacks, database-as-a-service, dll). Pengguna fokus men-deploy aplikasi tanpa mengurus detail infrastruktur; platform mengurus provisioning, scaling, patching. Contoh: Heroku, Google App Engine, Cloud Foundry.

SaaS (Software as a Service)** berada di tingkat paling atas: aplikasi langsung digunakan oleh end-user via web atau API. Penyedia mengelola seluruh stack (IaaS + PaaS + aplikasi). Contoh: Gmail, Salesforce.

Keterkaitanhhg
- IaaS adalah lapisan dasar (hardware + virtualisasi). PaaS memanfaatkan IaaS untuk menyediakan lingkungan pengembangan/deployment yang dikelola. SaaS dibangun di atas PaaS/IaaS — penyedia SaaS menggunakan platform (PaaS) atau langsung infrastruktur (IaaS) untuk menjalankan aplikasinya.
- Jika kamu ingin kontrol penuh atas OS atau konfigurasi network -> pilih IaaS. Jika ingin fokus menulis aplikasi tanpa urus infra -> gunakan PaaS. Jika butuh langsung menggunakan aplikasi jadi/siap pakai -> SaaS.


Soal 2 — Gambarkan diagram yang menunjukkan keterkaitan antara cloud native app teknologi container, PaaS, dan SaaS.


          ┌──────────────────────────┐
          │        IaaS Layer        │
          │ (VM, Network, Storage)   │
          └─────────────┬────────────┘
                        │
                        ▼
          ┌──────────────────────────┐
          │        PaaS Layer        │
          │  - Kubernetes / Orches.  │
          │  - Container Registry    │
          │  - Managed Database      │
          └─────────────┬────────────┘
                        │
                        ▼
     ┌──────────────────────────────────────┐
     │       Cloud Native Application       │
     │  - Docker / OCI Containers           │
     │  - Microservices Architecture        │
     │  - Service Mesh / Sidecar            │
     └────────────────────┬─────────────────┘
                          │
                          ▼
             ┌────────────────────────┐
             │         SaaS           │
             │ Aplikasi Web / Mobile  │
             │   Dipakai End-User     │
             └────────────────────────┘

soal 3
1. Perbandingan Kecepatan Python Free-Threaded (FT) vs Python GIL
 Hasil Utama

Free-Threaded (3.13-ft / 3.14-ft) lebih cepat ketika menjalankan multi-threaded tasks karena nggak pake GIL.

Python GIL (versi normal) tetap cepat untuk single-thread, tapi melambat ketika melakukan banyak operasi paralel di thread.

alasan:
Tanpa GIL → thread beneran paralel
Di versi normal, satu waktu cuma satu thread yang boleh eksekusi Python bytecode.

CPU Utilization lebih tinggi
FT bisa memakai multi-core dengan maksimal.

Cocok untuk I/O banyak dan task paralel ringan
Misal fetching API, scraping, worker paralel.

 Hasil Pengujian (contoh)
Mode	Waktu
AsyncIO	~0.58 detik
Multiprocessing	~1.40 detik

AsyncIO paling kencang karena non-blocking I/O.

2. Performa Multiprocessing
 Temuan:

Multiprocessing tetap powerful, tapi overhead tinggi.

Cocok untuk

CPU-bound tasks (heavy computation)

pekerjaan terpisah yang perlu CPU core masing-masing

 Kekurangan:

Start-up process berat

Inter-process communication lambat

Tidak cocok untuk request HTTP kecil-kecil

test :

Multiprocessing = 1.40 detik
AsyncIO = 0.58 detik

→ Artinya I/O ops jauh lebih cocok pake AsyncIO, bukan multiprocessing.

3. Isi README.md (yang sudah dibuat di workspace)

README berisi:

Penjelasan perbedaan FT vs GIL

Cara setup uv + Python FT

Contoh menjalankan script

Perbandingan hasil waktu AsyncIO vs Multiprocessing

Endpoint yang digunakan:
https://jsonplaceholder.typicode.com/todos/1

4. Endpoint JSON yang Diuji

Endpoint yang digunakan untuk UAT:

https://jsonplaceholder.typicode.com/todos/1


Endpoint ini ringan (fake API), cocok untuk test:

latency

async performance

overhead multiprocessing

Kesimpulan

FT Python = terbaik untuk thread-based parallelism (lebih cepat daripada GIL).

AsyncIO = tercepat untuk HTTP I/O dalam test ini.

Multiprocessing = powerful untuk CPU-bound, tapi lambat untuk I/O kecil.

README sudah berisi semua dokumentasi, hasil test, dan penjelasan teknis.
